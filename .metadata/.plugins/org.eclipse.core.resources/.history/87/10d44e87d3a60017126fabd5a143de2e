package com.yyh;
//Given a binary tree in which each node contains an integer number. Find the maximum possible 
// subpath sum(both the starting and ending node of the subpath should be on the same path from root 
// to one of the leaf nodes, and the subpath is allowed to contain only one node).

class TreeNode {
	public int key;
	public TreeNode left;
	public TreeNode right;
	public TreeNode(int key) {
		this.key = key;
	}
}

public class MaxPathSum {
	// Method 1: pass down the prefix sum
	public int maxPathSum(TreeNode root) {
		// Assumptions: root != null
		return maxPathSum(root, 0);
	}
	
	private int maxPathSum(TreeNode root, int sum){
		sum += root.key;
		if (root.left == null && root.right == null){
			return sum;
		} else if (root.left == null){
			return maxPathSum(root.right, sum);
		} else if (root.right == null){
			return maxPathSum(root.left, sum);
		}
		return Math.max(maxPathSum(root.left, sum), maxPathSum(root.right, sum)); 
	}
	
	// Method 2: Bottom up return the max suffix sum
	public int maxPathSumII(TreeNode root){
		// Assumptions: root != null
		if (root.left == null && root.right == null){
			return root.key;
		}
		if (root.left == null){
			return maxPathSum(root.right) + root.key;
		}
		if (root.right == null){
			return maxPathSum(root.left) + root.key;
		}
		return  root.key + Math.max(maxPathSum(root.left), maxPathSum(root.right));
	}
}
