package com.yyh;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Set;


// Num of words: N
// Avg length of word: M
// Time complexity: O(N(words) * M * M (dp scan)* M (substring)) = O(NM^3)
// Space complexity: O(N) for the dictionary and preSet
public class ConcatenatedWords {
	public static void main(String[] args){
		// Use String array to store the result:["1st CW", "2nd CW", TotalNum]
		String[] res = new String[3];
		// Read words from the file into List
		List<String> words = new ArrayList<>();
		try {
			File dir = new File(".");
			File fin = new File(dir.getCanonicalPath() + File.separator + "wordsforproblem.txt");
			FileReader fileReader = new FileReader(fin);
			BufferedReader br = new BufferedReader(fileReader);
			String line;
			while ((line = br.readLine()) != null) {
				words.add(line);
			}
			br.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		// Sort word for later dp operation and buffer
		// O(nlgn)
		words.sort(new Comparator<String>() {
			public int compare (String s1, String s2) {
				if (s1.length() == s2.length()){
					return 0;
				}
				return s1.length() < s2.length() ? -1 : 1;
			}
		});
		concatenatedWords(words, res);
		System.out.println(res[0] + " " + res[1] + " " + res[2]);
	}

	private static void concatenatedWords(List<String> words, String[] res) {
		Queue<String> buff = new LinkedList<>(); // As we only need 1st and 2nd longest word, a queue size of 2 could be maintained
		int count = 0;
		Set<String> pre = new HashSet<>();
		for (String cur : words) {
//			count++;
			// Check concatenation and storing
			if (helper(cur, pre)) {
				count++;
				if (count <= 2){
					buff.offer(cur);
				} else {
					buff.poll();
					buff.offer(cur);
				}
			}
			pre.add(cur);
		}
		res[2] = count + "";
		res[1] = buff.poll();
		res[0] = buff.poll();
	}

	// Use DP method to decide concatenation
	private static boolean helper(String cur, Set<String> pre) {
		if (pre.isEmpty()) {
			return false;
		}
		boolean[] M = new boolean[cur.length() + 1];
		M[0] = true;
		for (int i = 1; i <= cur.length(); i++) {
			// if the word is in the dictionary, done
			if (pre.contains(cur.substring(0, i))){
				M[i] = true;
				continue;
			}
			// check subproblem and check the rest of word.
			for (int j = 1; j < i; j++) {
				if (M[j] && pre.contains(cur.substring(j, i))) {
					M[i] = true;
					break;
				}
			}
		}
		return M[cur.length()];
	}
}
